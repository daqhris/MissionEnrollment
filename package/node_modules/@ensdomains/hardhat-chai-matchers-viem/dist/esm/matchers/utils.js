import { HardhatChaiMatchersNonChainableMatcherError } from "../errors.js";
import { PREVIOUS_MATCHER_NAME } from "./constants.js";
const getFlag = (assertion, flagName, defaultValue) => {
    const assertion_ = assertion;
    assertion_.__flags = assertion_.__flags || {};
    const value = assertion_.__flags[flagName];
    if (typeof value !== "undefined")
        return value;
    assertion_.__flags[flagName] = defaultValue;
    return assertion_.__flags[flagName];
};
const setFlag = (assertion, flagName, value) => {
    const assertion_ = assertion;
    assertion_.__flags = assertion_.__flags || {};
    assertion_.__flags[flagName] = value;
};
export const getNegated = (assertion) => getFlag(assertion, "negate", false);
export const getObject = (assertion) => getFlag(assertion, "object");
export const getHashOnly = (assertion) => getFlag(assertion, "hashOnly", false);
export const setHashOnly = (assertion, value) => setFlag(assertion, "hashOnly", value);
export const getWriteResult = (assertion) => getFlag(assertion, "writeResult");
export const setWriteResult = (assertion, value) => setFlag(assertion, "writeResult", value);
export const getReadResult = (assertion) => getFlag(assertion, "readResult");
export const setReadResult = (assertion, value) => setFlag(assertion, "readResult", value);
export const getWithArgs = (assertion) => getFlag(assertion, "withArgs");
export const setWithArgs = (assertion, value) => setFlag(assertion, "withArgs", value);
const getPreviousMatcherName = (assertion) => getFlag(assertion, PREVIOUS_MATCHER_NAME);
const setPreviousMatcherName = (assertion, value) => setFlag(assertion, PREVIOUS_MATCHER_NAME, value);
export const preventAsyncMatcherChaining = (assertion, { matcherName, allowSelfChaining = false, allowHashOnly = false, }) => {
    const previousMatcherName = getPreviousMatcherName(assertion);
    const hashOnly = getHashOnly(assertion);
    if (hashOnly && !allowHashOnly)
        throw new HardhatChaiMatchersNonChainableMatcherError(matcherName, "transaction(hash)");
    if (previousMatcherName === undefined) {
        setPreviousMatcherName(assertion, matcherName);
        return;
    }
    if (previousMatcherName === matcherName && allowSelfChaining) {
        return;
    }
    throw new HardhatChaiMatchersNonChainableMatcherError(matcherName, previousMatcherName);
};
//# sourceMappingURL=utils.js.map